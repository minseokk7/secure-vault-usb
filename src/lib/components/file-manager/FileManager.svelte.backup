<!--
  ë©”ì¸ íŒŒì¼ ë§¤ë‹ˆì € ì»´í¬ë„ŒíŠ¸
  C# MainFormì˜ ë ˆì´ì•„ì›ƒê³¼ ê¸°ëŠ¥ì„ Svelteë¡œ í¬íŒ…
-->
<script lang="ts">
  import { onMount } from 'svelte';
  import { writable } from 'svelte/store';
  import { invoke } from '@tauri-apps/api/core';
  import { 
    fileManagerState, 
    FileManagerService, 
    initializeFileManager,
    currentFolderPath,
    hasSelection,
    selectedItemsCount,
    hasFileSelection,
    selectedFileCount
  } from '$lib/stores/file-manager';
  import { addToast } from '$lib/stores/toast';
  import TitleBar from '$lib/components/common/TitleBar.svelte';
  import Button from '$lib/components/common/Button.svelte';
  import FolderTree from './FolderTree.svelte';
  import FileList from './FileList.svelte';
  import Toolbar from './Toolbar.svelte';
  import StatusBar from './StatusBar.svelte';

  import NewFileDialog from './NewFileDialog.svelte';
  import ExportDialog from './ExportDialog.svelte';
  import DeleteConfirmDialog from './DeleteConfirmDialog.svelte';
  import CreateFolderDialog from './CreateFolderDialog.svelte';
  import AddFileDialog from './AddFileDialog.svelte';
  import AddFolderDialog from './AddFolderDialog.svelte';
  import ProgressBar from '$lib/components/common/ProgressBar.svelte';

  import RenameDialog from './RenameDialog.svelte';
  const isLoading = $derived($fileManagerState.isLoading);
  const error = $derived($fileManagerState.error);
  const folderPath = $derived($currentFolderPath);
  const selectionCount = $derived($selectedItemsCount);
  const hasSelectedItems = $derived($hasSelection);

  // íŒŒì¼ ì„ íƒ ê´€ë ¨ ìƒíƒœ ê³„ì‚°
  const hasFileSelectionState = $derived($hasFileSelection);
  const selectedFileCountState = $derived($selectedFileCount);

  // íŒŒì¼ê³¼ í´ë” ëª©ë¡ ìƒíƒœ
  const files = $derived($fileManagerState.files);
  const folders = $derived($fileManagerState.folders);

  // ë‹¤ì´ì–¼ë¡œê·¸ ìƒíƒœ
  let showNewFileDialog = $state(false);
  let showExportDialog = $state(false);
  let showDeleteConfirmDialog = $state(false);
  let showCreateFolderDialog = $state(false);
  let showAddFileDialog = $state(false);
  let showAddFolderDialog = $state(false);

  // ì—…ë¡œë“œ ì§„í–‰ë¥  ê´€ë¦¬
  let uploadProgress = writable<Map<string, number>>(new Map());
  let isUploading = writable<boolean>(false);
  let currentUploadSessions = writable<Map<string, string>>(new Map()); // fileName -> sessionId
  let showRenameDialog = $state(false);

  // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ìƒíƒœ
  let isDragOver = $state(false);
  let dragCounter = $state(0);
  let isProcessingDrop = $state(false); // ë“œë¡­ ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ ì¶”ê°€

  // ì „ì—­ ë“œë¡­ ì²˜ë¦¬ ë°©ì§€ë¥¼ ìœ„í•œ ê³ ìœ  ID
  const componentId = `file-manager-${Date.now()}-${Math.random()}`;
  let isActiveInstance = $state(true); // í˜„ì¬ í™œì„± ì¸ìŠ¤í„´ìŠ¤ì¸ì§€ í™•ì¸

  // í…ìŠ¤íŠ¸ ë“œë˜ê·¸ ë°©ì§€ í•¨ìˆ˜ (íŒŒì¼ ë“œë˜ê·¸ ì•¤ ë“œë¡­ì€ í—ˆìš©)
  function preventTextDrag(e: DragEvent) {
    const target = e.target as HTMLElement;
    
    // ì™¸ë¶€ì—ì„œ íŒŒì¼ì„ ë“œë˜ê·¸í•´ì˜¤ëŠ” ê²½ìš°ëŠ” í—ˆìš©
    if (e.dataTransfer && e.dataTransfer.types.includes('Files')) {
      return; // íŒŒì¼ ë“œë˜ê·¸ëŠ” í—ˆìš©
    }
    
    // ë‚´ë¶€ í…ìŠ¤íŠ¸ ìš”ì†Œë“¤ì˜ ë“œë˜ê·¸ë§Œ ë°©ì§€
    if (target && (
      target.classList.contains('file-name') ||
      target.classList.contains('folder-name') ||
      target.classList.contains('file-item') ||
      target.classList.contains('folder-item') ||
      target.closest('.file-list') ||
      target.closest('.folder-tree')
    )) {
      console.log('í…ìŠ¤íŠ¸ ë“œë˜ê·¸ ë°©ì§€:', target.className);
      e.preventDefault();
      e.stopPropagation();
    }
  }

  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
  onMount(async () => {
    console.log('FileManager ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸:', componentId);
    
    // ì´ì „ ì¸ìŠ¤í„´ìŠ¤ë“¤ ë¹„í™œì„±í™”
    window.dispatchEvent(new CustomEvent('fileManagerMounted', { detail: { componentId } }));
    
    // íŒŒì¼ ë§¤ë‹ˆì € ì´ˆê¸°í™”ë¥¼ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰
    (async () => {
      try {
        await initializeFileManager();
        
        addToast({
          type: 'success',
          title: 'íŒŒì¼ ë§¤ë‹ˆì € ë¡œë“œ ì™„ë£Œ',
          message: 'íŒŒì¼ ë§¤ë‹ˆì €ê°€ ì„±ê³µì ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.',
          duration: 3000
        });
      } catch (error) {
        console.error('íŒŒì¼ ë§¤ë‹ˆì € ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
        
        addToast({
          type: 'error',
          title: 'ì´ˆê¸°í™” ì‹¤íŒ¨',
          message: 'íŒŒì¼ ë§¤ë‹ˆì €ë¥¼ ì´ˆê¸°í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
          duration: 5000
        });
      }
    })();

    // í´ë” ì´ë¦„ ë³€ê²½ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    const handleFolderRenameRequest = (event: CustomEvent) => {
      if (!isActiveInstance) return; // ë¹„í™œì„± ì¸ìŠ¤í„´ìŠ¤ëŠ” ë¬´ì‹œ
      
      const { folderId } = event.detail;
      const state = $fileManagerState;
      const folder = state.folders.find(f => f.id === folderId);
      
      if (folder) {
        // í´ë” ì„ íƒ ìƒíƒœë¡œ ë§Œë“¤ê³  ì´ë¦„ ë³€ê²½ ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
        FileManagerService.selectItem(folderId, 'folder', false);
        setTimeout(() => {
          handleRenameSelected();
        }, 100);
      }
    };

    // ë‹¤ë¥¸ FileManager ì¸ìŠ¤í„´ìŠ¤ê°€ ë§ˆìš´íŠ¸ë˜ë©´ í˜„ì¬ ì¸ìŠ¤í„´ìŠ¤ ë¹„í™œì„±í™”
    const handleFileManagerMounted = (event: CustomEvent) => {
      const { componentId: newComponentId } = event.detail;
      if (newComponentId !== componentId) {
        console.log('ë‹¤ë¥¸ FileManager ì¸ìŠ¤í„´ìŠ¤ê°€ ë§ˆìš´íŠ¸ë¨, í˜„ì¬ ì¸ìŠ¤í„´ìŠ¤ ë¹„í™œì„±í™”:', componentId);
        isActiveInstance = false;
      }
    };

    window.addEventListener('requestFolderRename', handleFolderRenameRequest as EventListener);
    window.addEventListener('fileManagerMounted', handleFileManagerMounted as EventListener);

    // HTML5 ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    const handleDragOver = (e: DragEvent) => {
      if (!isActiveInstance) return;
      console.log('ğŸ”¥ ë“œë˜ê·¸ ì˜¤ë²„ ì´ë²¤íŠ¸ ë°œìƒ!', e.type, e.dataTransfer?.types);
      e.preventDefault();
      e.stopPropagation();
      
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = 'copy';
      }
      
      dragCounter++;
      
      if (!isDragOver) {
        isDragOver = true;
        console.log('âœ… ë“œë˜ê·¸ ì˜¤ë²„ ìƒíƒœ í™œì„±í™” - dragCounter:', dragCounter);
      }
    };

    const handleDragLeave = (e: DragEvent) => {
      if (!isActiveInstance) return;
      e.preventDefault();
      e.stopPropagation();
      
      dragCounter--;
      console.log('ë“œë˜ê·¸ ë¦¬ë¸Œ - dragCounter:', dragCounter);
      
      // ëª¨ë“  ë“œë˜ê·¸ê°€ ëë‚¬ì„ ë•Œë§Œ ì˜¤ë²„ë ˆì´ ì œê±°
      if (dragCounter <= 0) {
        dragCounter = 0;
        isDragOver = false;
        console.log('ë“œë˜ê·¸ ì˜¤ë²„ ì¢…ë£Œ - isDragOver:', isDragOver);
      }
    };

    const handleDrop = async (e: DragEvent) => {
      console.log('ë“œë¡­ ì´ë²¤íŠ¸ ë°œìƒ:', e.dataTransfer?.files?.length);
      if (!isActiveInstance) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      // ë“œë˜ê·¸ ìƒíƒœ ì´ˆê¸°í™”
      isDragOver = false;
      dragCounter = 0;
      console.log('íŒŒì¼ ë“œë¡­ë¨ - isDragOver:', isDragOver);
      
      if (!e.dataTransfer?.files || e.dataTransfer.files.length === 0) {
        console.log('ë“œë¡­ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      
      if (isProcessingDrop) {
        console.log('ì´ë¯¸ ë“œë¡­ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤.');
        return;
      }
      
      isProcessingDrop = true;
      
      try {
        await handleFilesDrop(e);
      } catch (error) {
        console.error('ë“œë¡­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
      } finally {
        isProcessingDrop = false;
      }
    };

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    document.addEventListener('dragover', handleDragOver, false);
    document.addEventListener('dragleave', handleDragLeave, false);
    document.addEventListener('drop', handleDrop, false);
    document.addEventListener('dragstart', preventTextDrag, true);

    console.log('HTML5 ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ì™„ë£Œ');

    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
    return () => {
      console.log('FileManager ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸:', componentId);
      isActiveInstance = false;
      window.removeEventListener('requestFolderRename', handleFolderRenameRequest as EventListener);
      window.removeEventListener('fileManagerMounted', handleFileManagerMounted as EventListener);
      
      // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
      document.removeEventListener('dragover', handleDragOver, false);
      document.removeEventListener('dragleave', handleDragLeave, false);
      document.removeEventListener('drop', handleDrop, false);
      document.removeEventListener('dragstart', preventTextDrag, true);
    };
  });

  // íŒŒì¼ ì¶”ê°€ ì²˜ë¦¬ (ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°)
  function handleAddFile() {
    console.log('íŒŒì¼ ì¶”ê°€ ë²„íŠ¼ í´ë¦­ë¨ - ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°');
    showAddFileDialog = true;
  }

  // í´ë” ì¶”ê°€ ì²˜ë¦¬ (ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°)
  function handleAddFolder() {
    console.log('í´ë” ì¶”ê°€ ë²„íŠ¼ í´ë¦­ë¨ - ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°');
    showAddFolderDialog = true;
  }

  // íŒŒì¼ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ í™•ì¸ ì²˜ë¦¬
  async function handleAddFileConfirm(folderId?: string | null) {
    console.log('íŒŒì¼ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ í™•ì¸ë¨, í´ë” ID:', folderId);
    
    try {
      // Tauri íŒŒì¼ ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
      const { open } = await import('@tauri-apps/plugin-dialog');
      
      const selected = await open({
        multiple: true,
        filters: [{
          name: 'ëª¨ë“  íŒŒì¼',
          extensions: ['*']
        }]
      });

      console.log('íŒŒì¼ ë‹¤ì´ì–¼ë¡œê·¸ ê²°ê³¼:', selected);

      if (selected && Array.isArray(selected) && selected.length > 0) {
        console.log('ì„ íƒëœ íŒŒì¼ë“¤:', selected);
        await uploadFiles(selected, folderId);
      } else if (selected && typeof selected === 'string') {
        console.log('ì„ íƒëœ íŒŒì¼:', selected);
        await uploadFiles([selected], folderId);
      } else {
        console.log('íŒŒì¼ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('íŒŒì¼ ì„ íƒ ì‹¤íŒ¨:', error);
      addToast({
        type: 'error',
        title: 'íŒŒì¼ ì„ íƒ ì‹¤íŒ¨',
        message: `íŒŒì¼ì„ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${error}`,
        duration: 5000
      });
    } finally {
      showAddFileDialog = false;
    }
  }

  // ê¸°ë³¸ íŒŒì¼ ì—…ë¡œë“œ í•¨ìˆ˜
  async function uploadFiles(filePaths: string[], folderId?: string | null) {
    console.log('íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘:', filePaths);
    
    // ì—…ë¡œë“œ ì§„í–‰ë¥  ì‹œì‘
    const fileNames = filePaths.map(path => path.split(/[/\\]/).pop() || 'unknown');
    startUpload(fileNames);
    
    let successCount = 0;
    let errorCount = 0;
    const errors: string[] = [];
    
    addToast({
      type: 'info',
      title: 'íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘',
      message: `${filePaths.length}ê°œ íŒŒì¼ì„ ì—…ë¡œë“œí•©ë‹ˆë‹¤.`,
      duration: 3000
    });
    
    try {
      const { readFile } = await import('@tauri-apps/plugin-fs');
      const { invoke } = await import('@tauri-apps/api/core');
      
      // ë³¼íŠ¸ ì´ˆê¸°í™” í™•ì¸
      try {
        await invoke('initialize_vault', {
          vaultName: null,
          vaultPath: null
        });
        console.log('ë³¼íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ');
      } catch (initError) {
        console.error('ë³¼íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨:', initError);
        // ì´ˆê¸°í™” ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
      }
      
      for (const filePath of filePaths) {
        try {
          console.log('íŒŒì¼ ì½ê¸° ì‹œì‘:', filePath);
          
          // íŒŒì¼ ì´ë¦„ ì¶”ì¶œ
          const fileName = filePath.split(/[/\\]/).pop() || 'unknown';
          
          // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì‹œì‘)
          updateUploadProgress(fileName, 10);
          
          // íŒŒì¼ ë°ì´í„° ì½ê¸°
          const fileData = await readFile(filePath);
          const uint8Array = new Uint8Array(fileData);
          
          // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì½ê¸° ì™„ë£Œ)
          updateUploadProgress(fileName, 50);
          
          // Base64ë¡œ ì¸ì½”ë”© (í° íŒŒì¼ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì²­í¬ ë°©ì‹)
          let base64Content = '';
          const chunkSize = 8192; // 8KB ì²­í¬
          
          for (let i = 0; i < uint8Array.length; i += chunkSize) {
            const chunk = uint8Array.slice(i, i + chunkSize);
            const chunkString = Array.from(chunk, byte => String.fromCharCode(byte)).join('');
            base64Content += btoa(chunkString);
            
            // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì¸ì½”ë”© ì§„í–‰)
            const encodeProgress = 50 + Math.floor((i / uint8Array.length) * 30);
            updateUploadProgress(fileName, encodeProgress);
          }
          
          // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì¸ì½”ë”© ì™„ë£Œ)
          updateUploadProgress(fileName, 80);
          
          // ê¸°ë³¸ íŒŒì¼ ì¶”ê°€ ì»¤ë§¨ë“œ í˜¸ì¶œ (create_binary_file_in_vault ì‚¬ìš©)
          await invoke('create_binary_file_in_vault', {
            folderId: folderId,
            fileName: fileName,
            content: base64Content
          });
          
          // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì™„ë£Œ)
          updateUploadProgress(fileName, 100);
          
          console.log('íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ:', fileName);
          successCount++;
          
        } catch (error) {
          console.error('íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:', filePath, error);
          errorCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          errors.push(`${filePath}: ${errorMessage}`);
          
          // ì‹¤íŒ¨í•œ íŒŒì¼ ì§„í–‰ë¥ ì—ì„œ ì œê±°
          const fileName = filePath.split(/[/\\]/).pop() || 'unknown';
          handleUploadError(fileName);
        }
      }
      
      // ì—…ë¡œë“œ ì™„ë£Œ í›„ ìƒˆë¡œê³ ì¹¨
      if (successCount > 0) {
        await FileManagerService.refresh();
        
        addToast({
          type: 'success',
          title: 'íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ',
          message: `${successCount}ê°œ íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`,
          duration: 4000
        });
      }
      
      if (errorCount > 0) {
        console.error('ì—…ë¡œë“œ ì‹¤íŒ¨í•œ íŒŒì¼ë“¤:', errors);
        addToast({
          type: 'error',
          title: 'ì¼ë¶€ íŒŒì¼ ì‹¤íŒ¨',
          message: `${errorCount}ê°œ íŒŒì¼ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`,
          duration: 5000
        });
      }
      
    } catch (error) {
      console.error('íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:', error);
      addToast({
        type: 'error',
        title: 'íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨',
        message: `íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`,
        duration: 5000
      });
    }
  }

  // ì••ì¶• ê¸°ë°˜ íŒŒì¼ ì—…ë¡œë“œ í•¨ìˆ˜ (ì‚¬ìš© ì•ˆí•¨)
  async function uploadFilesWithCompression(filePaths: string[], folderId?: string | null) {
    console.log('ì••ì¶• ê¸°ë°˜ íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘:', filePaths);
    
    let successCount = 0;
    let errorCount = 0;
    const errors: string[] = [];
    
    addToast({
      type: 'info',
      title: 'ì••ì¶• ì—…ë¡œë“œ ì‹œì‘',
      message: `${filePaths.length}ê°œ íŒŒì¼ì„ ì••ì¶•í•˜ì—¬ ì—…ë¡œë“œí•©ë‹ˆë‹¤.`,
      duration: 3000
    });
    
    try {
      const { readFile } = await import('@tauri-apps/plugin-fs');
      const { invoke } = await import('@tauri-apps/api/core');
      
      for (const filePath of filePaths) {
        try {
          console.log('íŒŒì¼ ì½ê¸° ì‹œì‘:', filePath);
          
          // íŒŒì¼ ì´ë¦„ ì¶”ì¶œ
          const fileName = filePath.split(/[/\\]/).pop() || 'unknown';
          
          // íŒŒì¼ ë°ì´í„° ì½ê¸°
          const fileData = await readFile(filePath);
          const uint8Array = new Uint8Array(fileData);
          
          // íŒŒì¼ì´ í…ìŠ¤íŠ¸ íŒŒì¼ì¸ì§€ í™•ì¸
          const isTextFile = isLikelyTextFile(fileName, uint8Array);
          
          if (isTextFile) {
            // í…ìŠ¤íŠ¸ íŒŒì¼ë¡œ ì••ì¶• ì²˜ë¦¬
            try {
              const content = new TextDecoder('utf-8').decode(uint8Array);
              await invoke('create_compressed_text_file_in_vault', {
                folderId: folderId,
                fileName: fileName,
                content: content
              });
              console.log('ì••ì¶• í…ìŠ¤íŠ¸ íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ:', fileName);
              successCount++;
            } catch (decodeError) {
              // UTF-8 ë””ì½”ë”© ì‹¤íŒ¨ ì‹œ ë°”ì´ë„ˆë¦¬ë¡œ ì²˜ë¦¬
              console.log('UTF-8 ë””ì½”ë”© ì‹¤íŒ¨, ì••ì¶• ë°”ì´ë„ˆë¦¬ë¡œ ì²˜ë¦¬:', fileName);
              const base64Content = btoa(String.fromCharCode(...uint8Array));
              await invoke('create_compressed_binary_file_in_vault', {
                folderId: folderId,
                fileName: fileName,
                content: base64Content
              });
              console.log('ì••ì¶• ë°”ì´ë„ˆë¦¬ íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ:', fileName);
              successCount++;
            }
          } else {
            // ë°”ì´ë„ˆë¦¬ íŒŒì¼ë¡œ ì••ì¶• ì²˜ë¦¬
            console.log(`ì••ì¶• ë°”ì´ë„ˆë¦¬ íŒŒì¼ ì²˜ë¦¬: ${fileName} (${(uint8Array.length / 1024 / 1024).toFixed(2)}MB)`);
            
            const base64Content = btoa(String.fromCharCode(...uint8Array));
            await invoke('create_compressed_binary_file_in_vault', {
              folderId: folderId,
              fileName: fileName,
              content: base64Content
            });
            console.log('ì••ì¶• ë°”ì´ë„ˆë¦¬ íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ:', fileName);
            successCount++;
          }
          
        } catch (error) {
          console.error('íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:', filePath, error);
          errorCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          errors.push(`${filePath}: ${errorMessage}`);
        }
      }
      
      // ì—…ë¡œë“œ ì™„ë£Œ í›„ ìƒˆë¡œê³ ì¹¨
      if (successCount > 0) {
        await FileManagerService.refresh();
        
        addToast({
          type: 'success',
          title: 'ì••ì¶• ì—…ë¡œë“œ ì™„ë£Œ',
          message: `${successCount}ê°œ íŒŒì¼ì´ ì••ì¶•ë˜ì–´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`,
          duration: 4000
        });
      }
      
      if (errorCount > 0) {
        console.error('ì—…ë¡œë“œ ì‹¤íŒ¨í•œ íŒŒì¼ë“¤:', errors);
        addToast({
          type: 'error',
          title: 'ì¼ë¶€ íŒŒì¼ ì‹¤íŒ¨',
          message: `${errorCount}ê°œ íŒŒì¼ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`,
          duration: 5000
        });
      }
      
    } catch (error) {
      console.error('ì••ì¶• ê¸°ë°˜ íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:', error);
      addToast({
        type: 'error',
        title: 'ì••ì¶• ì—…ë¡œë“œ ì‹¤íŒ¨',
        message: `íŒŒì¼ ì••ì¶• ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`,
        duration: 5000
      });
    }
  }

  // íŒŒì¼ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ ì·¨ì†Œ ì²˜ë¦¬
  function handleAddFileCancel() {
    console.log('íŒŒì¼ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ ì·¨ì†Œë¨');
    showAddFileDialog = false;
  }

  // í´ë” ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ í™•ì¸ ì²˜ë¦¬
  async function handleAddFolderConfirm(folderId?: string | null) {
    console.log('í´ë” ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ í™•ì¸ë¨, í´ë” ID:', folderId);
    
    try {
      // Tauri í´ë” ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
      const { open } = await import('@tauri-apps/plugin-dialog');
      
      const selected = await open({
        directory: true,
        multiple: false,
        title: 'ì¶”ê°€í•  í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”'
      });

      console.log('í´ë” ë‹¤ì´ì–¼ë¡œê·¸ ê²°ê³¼:', selected);

      if (selected && typeof selected === 'string') {
        console.log('ì„ íƒëœ í´ë”:', selected);
        await FileManagerService.addFolder(selected, folderId || undefined);
      } else {
        console.log('í´ë”ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('í´ë” ì„ íƒ ì‹¤íŒ¨:', error);
      addToast({
        type: 'error',
        title: 'í´ë” ì„ íƒ ì‹¤íŒ¨',
        message: `í´ë”ë¥¼ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${error}`,
        duration: 5000
      });
    } finally {
      showAddFolderDialog = false;
    }
  }

  // í´ë” ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ ì·¨ì†Œ ì²˜ë¦¬
  function handleAddFolderCancel() {
    console.log('í´ë” ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ ì·¨ì†Œë¨');
    showAddFolderDialog = false;
  }

  // ìƒˆ íŒŒì¼ ìƒì„± ì²˜ë¦¬
  function handleCreateFile() {
    console.log('ìƒˆ íŒŒì¼ ìƒì„± ë²„íŠ¼ í´ë¦­ë¨'); // ë””ë²„ê¹…ìš© ë¡œê·¸
    showNewFileDialog = true;
  }

  // ìƒˆ íŒŒì¼ ìƒì„± ë‹¤ì´ì–¼ë¡œê·¸ì—ì„œ ìƒì„± ë²„íŠ¼ í´ë¦­ (props í•¨ìˆ˜ ë°©ì‹)
  async function handleNewFileCreate(fileName: string, content: string, folderId?: string | null) {
    try {
      const { invoke } = await import('@tauri-apps/api/core');
      
      console.log('íŒŒì¼ ìƒì„± ìš”ì²­:', { fileName, contentLength: content.length, folderId });
      
      // ìƒˆ íŒŒì¼ ìƒì„± ì»¤ë§¨ë“œ í˜¸ì¶œ
      const createdFile = await invoke('create_new_file_in_vault', {
        folderId: folderId,
        fileName: fileName,
        content: content
      });

      console.log('íŒŒì¼ ìƒì„± ì„±ê³µ:', createdFile);

      // ì„±ê³µ í† ìŠ¤íŠ¸ í‘œì‹œ
      addToast({
        type: 'success',
        title: 'íŒŒì¼ ìƒì„± ì™„ë£Œ',
        message: `íŒŒì¼ '${fileName}'ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.`,
        duration: 3000
      });

      // íŒŒì¼ ìƒì„± í›„ í˜„ì¬ í´ë” ìƒˆë¡œê³ ì¹¨
      await FileManagerService.refresh();

    } catch (error) {
      console.error('íŒŒì¼ ìƒì„± ì‹¤íŒ¨:', error);
      
      addToast({
        type: 'error',
        title: 'íŒŒì¼ ìƒì„± ì‹¤íŒ¨',
        message: `íŒŒì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`,
        duration: 5000
      });
    } finally {
      // ì„±ê³µ/ì‹¤íŒ¨ ê´€ê³„ì—†ì´ ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°
      showNewFileDialog = false;
    }
  }

  // ìƒˆ íŒŒì¼ ìƒì„± ë‹¤ì´ì–¼ë¡œê·¸ ì·¨ì†Œ
  function handleNewFileCancel() {
    showNewFileDialog = false;
  }

  // í´ë” ìƒì„± ì²˜ë¦¬
  function handleCreateFolder() {
    console.log('í´ë” ìƒì„± ë²„íŠ¼ í´ë¦­ë¨'); // ë””ë²„ê¹…ìš© ë¡œê·¸
    showCreateFolderDialog = true;
  }

  // í´ë” ìƒì„± ë‹¤ì´ì–¼ë¡œê·¸ì—ì„œ í™•ì¸
  async function handleCreateFolderConfirm(folderName: string) {
    try {
      console.log('í´ë” ìƒì„± ìš”ì²­:', folderName); // ë””ë²„ê¹…ìš© ë¡œê·¸
      
      const currentFolder = $fileManagerState.currentFolder;
      await FileManagerService.createFolder(folderName, currentFolder?.id);

    } catch (error) {
      console.error('í´ë” ìƒì„± ì‹¤íŒ¨:', error);
      
      addToast({
        type: 'error',
        title: 'í´ë” ìƒì„± ì‹¤íŒ¨',
        message: `í´ë” ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`,
        duration: 5000
      });
    } finally {
      // ì„±ê³µ/ì‹¤íŒ¨ ê´€ê³„ì—†ì´ ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°
      showCreateFolderDialog = false;
    }
  }

  // í´ë” ìƒì„± ë‹¤ì´ì–¼ë¡œê·¸ ì·¨ì†Œ
  function handleCreateFolderCancel() {
    showCreateFolderDialog = false;
  }

  // ì„ íƒëœ í•­ëª© ì‚­ì œ
  async function handleDeleteSelected() {
    if (!hasSelectedItems) return;
    
    // ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
    showDeleteConfirmDialog = true;
  }

  // ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ì—ì„œ ì‚­ì œ í™•ì¸
  async function handleDeleteConfirm() {
    try {
      const state = $fileManagerState;
      const selectedFiles = Array.from(state.selection.selectedFiles);
      const selectedFolders = Array.from(state.selection.selectedFolders);
      
      console.log('ì‚­ì œ í™•ì¸ë¨:', { selectedFiles, selectedFolders }); // ë””ë²„ê¹…ìš© ë¡œê·¸
      
      // íŒŒì¼ ì‚­ì œ
      if (selectedFiles.length > 0) {
        await FileManagerService.deleteItems(selectedFiles, 'file');
      }
      
      // í´ë” ì‚­ì œ
      if (selectedFolders.length > 0) {
        await FileManagerService.deleteItems(selectedFolders, 'folder');
      }

      // ì„ íƒ í•´ì œ
      FileManagerService.clearSelection();

      // íŒŒì¼ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
      await FileManagerService.refresh();

    } catch (error) {
      console.error('ì‚­ì œ ì‹¤íŒ¨:', error);
      
      addToast({
        type: 'error',
        title: 'ì‚­ì œ ì‹¤íŒ¨',
        message: `ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`,
        duration: 5000
      });
    } finally {
      // ì„±ê³µ/ì‹¤íŒ¨ ê´€ê³„ì—†ì´ ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°
      showDeleteConfirmDialog = false;
    }
  }

  // ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ ì·¨ì†Œ
  function handleDeleteCancel() {
    showDeleteConfirmDialog = false;
  }

  // ì„ íƒëœ íŒŒì¼ ë‚´ë³´ë‚´ê¸°
  async function handleExportSelected() {
    if (!hasSelectedItems) return;
    
    const state = $fileManagerState;
    const selectedFiles = Array.from(state.selection.selectedFiles);
    const selectedFolders = Array.from(state.selection.selectedFolders);
    
    if (selectedFiles.length === 0 && selectedFolders.length === 0) {
      addToast({
        type: 'warning',
        title: 'í•­ëª© ì„ íƒ í•„ìš”',
        message: 'ë‚´ë³´ë‚¼ íŒŒì¼ ë˜ëŠ” í´ë”ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.',
        duration: 3000
      });
      return;
    }

    // ì„ íƒëœ íŒŒì¼ë“¤ì˜ ë©”íƒ€ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    const filesToExport = state.files.filter(file => selectedFiles.includes(file.id));
    const foldersToExport = state.folders.filter(folder => selectedFolders.includes(folder.id));
    
    if (filesToExport.length === 0 && foldersToExport.length === 0) {
      addToast({
        type: 'error',
        title: 'í•­ëª© ì •ë³´ ì˜¤ë¥˜',
        message: 'ì„ íƒëœ í•­ëª©ì˜ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
        duration: 5000
      });
      return;
    }

    // ë‚´ë³´ë‚´ê¸° ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
    showExportDialog = true;
  }

  // ì„ íƒëœ í•­ëª© ì´ë¦„ ë³€ê²½ (íŒŒì¼ ë˜ëŠ” í´ë”)
  function handleRenameSelected() {
    const state = $fileManagerState;
    const selectedFiles = Array.from(state.selection.selectedFiles);
    const selectedFolders = Array.from(state.selection.selectedFolders);
    
    // íŒŒì¼ ë˜ëŠ” í´ë”ê°€ í•˜ë‚˜ë§Œ ì„ íƒë˜ì—ˆëŠ”ì§€ í™•ì¸
    const totalSelected = selectedFiles.length + selectedFolders.length;
    if (totalSelected !== 1) {
      addToast({
        type: 'warning',
        title: 'í•­ëª© ì„ íƒ í•„ìš”',
        message: 'ì´ë¦„ì„ ë³€ê²½í•  íŒŒì¼ ë˜ëŠ” í´ë”ë¥¼ í•˜ë‚˜ë§Œ ì„ íƒí•´ì£¼ì„¸ìš”.',
        duration: 3000
      });
      return;
    }

    // ì„ íƒëœ í•­ëª© ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    if (selectedFiles.length === 1) {
      const selectedFile = state.files.find(file => file.id === selectedFiles[0]);
      if (!selectedFile) {
        addToast({
          type: 'error',
          title: 'íŒŒì¼ ì •ë³´ ì˜¤ë¥˜',
          message: 'ì„ íƒëœ íŒŒì¼ì˜ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
          duration: 5000
        });
        return;
      }

      console.log('ì´ë¦„ ë³€ê²½í•  íŒŒì¼:', selectedFile);
      
      // íŒŒì¼ ì´ë¦„ ë³€ê²½ ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
      showRenameDialog = true;
    } else if (selectedFolders.length === 1) {
      const selectedFolder = state.folders.find(folder => folder.id === selectedFolders[0]);
      if (!selectedFolder) {
        addToast({
          type: 'error',
          title: 'í´ë” ì •ë³´ ì˜¤ë¥˜',
          message: 'ì„ íƒëœ í´ë”ì˜ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
          duration: 5000
        });
        return;
      }

      console.log('ì´ë¦„ ë³€ê²½í•  í´ë”:', selectedFolder);
      
      // í´ë” ì´ë¦„ ë³€ê²½ ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
      showRenameDialog = true;
    }
  }

  // ë‚´ë³´ë‚´ê¸° ë‹¤ì´ì–¼ë¡œê·¸ì—ì„œ ë‚´ë³´ë‚´ê¸° ì™„ë£Œ
  function handleExportComplete(event: CustomEvent<{ files: any[]; folders: any[]; exportPath: string }>) {
    const { files, folders, exportPath } = event.detail;
    const totalCount = files.length + folders.length;
    
    addToast({
      type: 'success',
      title: 'ë‚´ë³´ë‚´ê¸° ì™„ë£Œ',
      message: `${totalCount}ê°œ í•­ëª©ì´ ì„±ê³µì ìœ¼ë¡œ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤.`,
      duration: 4000
    });

    // ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°
    showExportDialog = false;
    
    // ì„ íƒ í•´ì œ
    FileManagerService.clearSelection();
  }

  // ë‚´ë³´ë‚´ê¸° ë‹¤ì´ì–¼ë¡œê·¸ ì·¨ì†Œ
  function handleExportCancel() {
    showExportDialog = false;
  }

  // ì´ë¦„ ë³€ê²½ ë‹¤ì´ì–¼ë¡œê·¸ ì·¨ì†Œ
  function handleRenameCancel() {
    showRenameDialog = false;
  }

  // ì´ë¦„ ë³€ê²½ ì™„ë£Œ ì²˜ë¦¬
  function handleRenameComplete(event: CustomEvent<{ file?: any; folder?: any; newName: string }>) {
    const { file, folder, newName } = event.detail;
    
    if (file) {
      addToast({
        type: 'success',
        title: 'íŒŒì¼ ì´ë¦„ ë³€ê²½ ì™„ë£Œ',
        message: `íŒŒì¼ ì´ë¦„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤: ${file.file_name} â†’ ${newName}`,
        duration: 3000
      });
    } else if (folder) {
      addToast({
        type: 'success',
        title: 'í´ë” ì´ë¦„ ë³€ê²½ ì™„ë£Œ',
        message: `í´ë” ì´ë¦„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤: ${folder.name} â†’ ${newName}`,
        duration: 3000
      });
    }

    // íŒŒì¼ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
    FileManagerService.refresh();
    
    // ì„ íƒ í•´ì œ
    FileManagerService.clearSelection();
    
    // ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°
    showRenameDialog = false;
  }

  // ì—ëŸ¬ ë©”ì‹œì§€ ë‹«ê¸°
  function handleCloseError() {
    FileManagerService.clearError();
  }

  // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ì²˜ë¦¬
  function handleKeyDown(event: KeyboardEvent) {
    // Delete: ì„ íƒëœ í•­ëª© ì‚­ì œ
    if (event.key === 'Delete' && hasSelectedItems) {
      event.preventDefault();
      handleDeleteSelected();
    }
    
    // F2: íŒŒì¼ ì´ë¦„ ë³€ê²½
    if (event.key === 'F2') {
      event.preventDefault();
      handleRenameSelected();
    }
    
    // Ctrl+A: ëª¨ë‘ ì„ íƒ
    if (event.ctrlKey && event.key === 'a') {
      event.preventDefault();
      // TODO: ëª¨ë“  í•­ëª© ì„ íƒ ë¡œì§
    }
    
    // Escape: ì„ íƒ í•´ì œ
    if (event.key === 'Escape') {
      FileManagerService.clearSelection();
    }
  }

  // ì§ì ‘ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (ë” í™•ì‹¤í•œ ë°©ë²•)
  function handleDragOverDirect(e: DragEvent) {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = 'copy';
    }
    
    if (!isDragOver) {
      isDragOver = true;
      console.log('ì§ì ‘ ë“œë˜ê·¸ ì˜¤ë²„ ì‹œì‘ - isDragOver:', isDragOver);
    }
  }

  function handleDragLeaveDirect(e: DragEvent) {
    e.preventDefault();
    e.stopPropagation();
    
    // íŒŒì¼ ë§¤ë‹ˆì € ì˜ì—­ì„ ì™„ì „íˆ ë²—ì–´ë‚¬ì„ ë•Œë§Œ ì˜¤ë²„ë ˆì´ ì œê±°
    const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
    const x = e.clientX;
    const y = e.clientY;
    
    if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
      isDragOver = false;
      console.log('ì§ì ‘ ë“œë˜ê·¸ ë¦¬ë¸Œ - isDragOver:', isDragOver);
    }
  }

  async function handleDropDirect(e: DragEvent) {
    e.preventDefault();
    e.stopPropagation();
    
    isDragOver = false;
    console.log('ì§ì ‘ íŒŒì¼ ë“œë¡­ë¨ - isDragOver:', isDragOver);
    
    if (!e.dataTransfer?.files || e.dataTransfer.files.length === 0) {
      console.log('ë“œë¡­ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    
    if (isProcessingDrop) {
      console.log('ì´ë¯¸ ë“œë¡­ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤.');
      return;
    }
    
    isProcessingDrop = true;
    
    try {
      await handleFilesDrop(e);
    } catch (error) {
      console.error('ë“œë¡­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
    } finally {
      isProcessingDrop = false;
    }
  }

  async function handleFilesDrop(event: DragEvent) {
    console.log('íŒŒì¼ ë“œë¡­ ì²˜ë¦¬ ì‹œì‘:', event);
    
    if (!event.dataTransfer) {
      console.log('ë“œë˜ê·¸ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      addToast({
        type: 'error',
        title: 'ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜¤ë¥˜',
        message: 'ë“œë˜ê·¸ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
        duration: 3000
      });
      return;
    }
    
    const files = Array.from(event.dataTransfer.files);
    console.log('ë“œë¡­ëœ íŒŒì¼ë“¤:', files.map(f => ({ name: f.name, size: f.size, type: f.type })));
    
    if (files.length === 0) {
      console.log('ë“œë¡­ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
      addToast({
        type: 'warning',
        title: 'íŒŒì¼ ì—†ìŒ',
        message: 'ë“œë¡­ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.',
        duration: 3000
      });
      return;
    }
    
    // ê¸°ë³¸ íŒŒì¼ í¬ê¸° ì œí•œ
    const maxFileSize = 1024 * 1024 * 1024; // 1GB
    const oversizedFiles = files.filter(file => file.size > maxFileSize);
    
    if (oversizedFiles.length > 0) {
      const fileInfo = oversizedFiles.map(f => `${f.name} (${(f.size / 1024 / 1024).toFixed(1)}MB)`).join(', ');
      console.log('íŒŒì¼ í¬ê¸° ì´ˆê³¼:', oversizedFiles.map(f => ({ name: f.name, size: f.size })));
      addToast({
        type: 'error',
        title: 'íŒŒì¼ í¬ê¸° ì œí•œ ì´ˆê³¼',
        message: `ë‹¤ìŒ íŒŒì¼ë“¤ì´ 1GB ì œí•œì„ ì´ˆê³¼í•©ë‹ˆë‹¤: ${fileInfo}`,
        duration: 5000
      });
      return;
    }

    // í˜„ì¬ í´ë” ID ê°€ì ¸ì˜¤ê¸°
    const state = $fileManagerState;
    const currentFolderId = state.currentFolderId;
    
    console.log('HTML5 íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘:', files.length, 'ê°œ íŒŒì¼');
    console.log('ëŒ€ìƒ í´ë” ID:', currentFolderId);
    
    // HTML5 File ê°ì²´ë¥¼ ì‚¬ìš©í•œ ì—…ë¡œë“œ
    await uploadFilesFromFileObjects(files, currentFolderId);
  }

  // HTML5 File ê°ì²´ë¥¼ ì‚¬ìš©í•œ íŒŒì¼ ì—…ë¡œë“œ í•¨ìˆ˜
  async function uploadFilesFromFileObjects(files: File[], folderId?: string | null) {
    console.log('HTML5 File ê°ì²´ ì—…ë¡œë“œ ì‹œì‘:', files.length, 'ê°œ íŒŒì¼');
    
    let successCount = 0;
    let errorCount = 0;
    const errors: string[] = [];
    
    addToast({
      type: 'info',
      title: 'íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘',
      message: `${files.length}ê°œ íŒŒì¼ì„ ì—…ë¡œë“œí•©ë‹ˆë‹¤.`,
      duration: 3000
    });
    
    try {
      // ë³¼íŠ¸ ì´ˆê¸°í™” í™•ì¸
      if (!$fileManagerState.isInitialized) {
        console.log('ë³¼íŠ¸ ì´ˆê¸°í™” ì¤‘...');
        await initializeFileManager();
      }
      console.log('ë³¼íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ');
      
      for (const file of files) {
        const fileName = file.name;
        console.log('íŒŒì¼ ì²˜ë¦¬ ì‹œì‘:', fileName);
        
        try {
          // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì‹œì‘)
          updateUploadProgress(fileName, 10);
          
          // File ê°ì²´ë¥¼ ArrayBufferë¡œ ì½ê¸°
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          
          // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì½ê¸° ì™„ë£Œ)
          updateUploadProgress(fileName, 50);
          
          // Base64ë¡œ ì¸ì½”ë”© (í° íŒŒì¼ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì²­í¬ ë°©ì‹)
          let base64Content = '';
          const chunkSize = 8192; // 8KB ì²­í¬
          
          for (let i = 0; i < uint8Array.length; i += chunkSize) {
            const chunk = uint8Array.slice(i, i + chunkSize);
            const chunkString = Array.from(chunk, byte => String.fromCharCode(byte)).join('');
            base64Content += btoa(chunkString);
            
            // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì¸ì½”ë”© ì§„í–‰)
            const encodeProgress = 50 + Math.floor((i / uint8Array.length) * 30);
            updateUploadProgress(fileName, encodeProgress);
          }
          
          // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì¸ì½”ë”© ì™„ë£Œ)
          updateUploadProgress(fileName, 80);
          
          // ê¸°ë³¸ íŒŒì¼ ì¶”ê°€ ì»¤ë§¨ë“œ í˜¸ì¶œ
          await invoke('create_binary_file_in_vault', {
            folderId: folderId,
            fileName: fileName,
            content: base64Content
          });
          
          // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì™„ë£Œ)
          updateUploadProgress(fileName, 100);
          
          console.log('íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ:', fileName);
          successCount++;
          
        } catch (error) {
          console.error('íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:', fileName, error);
          errorCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          errors.push(`${fileName}: ${errorMessage}`);
          
          // ì‹¤íŒ¨í•œ íŒŒì¼ ì§„í–‰ë¥ ì—ì„œ ì œê±°
          handleUploadError(fileName);
        }
      }
      
      // ì—…ë¡œë“œ ì™„ë£Œ í›„ ìƒˆë¡œê³ ì¹¨
      if (successCount > 0) {
        await FileManagerService.refresh();
        
        addToast({
          type: 'success',
          title: 'íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ',
          message: `${successCount}ê°œ íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`,
          duration: 4000
        });
      }
      
      if (errorCount > 0) {
        console.error('ì—…ë¡œë“œ ì‹¤íŒ¨í•œ íŒŒì¼ë“¤:', errors);
        addToast({
          type: 'error',
          title: 'ì¼ë¶€ íŒŒì¼ ì‹¤íŒ¨',
          message: `${errorCount}ê°œ íŒŒì¼ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`,
          duration: 5000
        });
      }
      
    } catch (error) {
      console.error('HTML5 íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:', error);
      addToast({
        type: 'error',
        title: 'íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨',
        message: `íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`,
        duration: 5000
      });
    }
  }

  // ArrayBufferë¥¼ ì•ˆì „í•˜ê²Œ base64ë¡œ ì¸ì½”ë”©í•˜ëŠ” í•¨ìˆ˜ (Promise ê¸°ë°˜)
      
      // íŒŒì¼ë“¤ì„ ì§ì ‘ ì²˜ë¦¬ (File ê°ì²´ ì‚¬ìš©)
      for (const file of files) {
        try {
          console.log(`íŒŒì¼ ì²˜ë¦¬ ì‹œì‘: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)`);
          
          // 200MB ì´ìƒ íŒŒì¼ì€ ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œ ì‚¬ìš©
          if (file.size > 200 * 1024 * 1024) {
            console.log(`í° íŒŒì¼ ê°ì§€, ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œ ì‚¬ìš©: ${file.name}`);
            await uploadFileWithStreaming(file, targetFolderId);
          } else {
            // ì‘ì€ íŒŒì¼ì€ ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©
            // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì‹œì‘)
            updateUploadProgress(file.name, 10);
            
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì½ê¸° ì™„ë£Œ)
            updateUploadProgress(file.name, 50);
            
            // ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ base64 ë³€í™˜
            const base64Content = await arrayBufferToBase64(arrayBuffer);
            
            // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì¸ì½”ë”© ì™„ë£Œ)
            updateUploadProgress(file.name, 80);
            
            const { invoke } = await import('@tauri-apps/api/core');
            
            // ë³¼íŠ¸ ì´ˆê¸°í™” í™•ì¸
            try {
              await invoke('initialize_vault', {
                vaultName: null,
                vaultPath: null
              });
              console.log('ë³¼íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ');
            } catch (initError) {
              console.error('ë³¼íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨:', initError);
              // ì´ˆê¸°í™” ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
            }
            
            // ê¸°ë³¸ íŒŒì¼ ì¶”ê°€ ì»¤ë§¨ë“œ í˜¸ì¶œ (create_binary_file_in_vault ì‚¬ìš©)
            await invoke('create_binary_file_in_vault', {
              folderId: targetFolderId,
              fileName: file.name,
              content: base64Content
            });
            
            // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (ì™„ë£Œ)
            updateUploadProgress(file.name, 100);
          }
          
          console.log('íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ:', file.name);
          
        } catch (error) {
          console.error('íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:', file.name, error);
          
          // ì‹¤íŒ¨í•œ íŒŒì¼ ì§„í–‰ë¥ ì—ì„œ ì œê±°
          handleUploadError(file.name);
          
          throw error;
        }
      }
      
      // ì—…ë¡œë“œ ì™„ë£Œ í›„ ìƒˆë¡œê³ ì¹¨
      await FileManagerService.refresh();
      
      addToast({
        type: 'success',
        title: 'íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ',
        message: 'íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.',
        duration: 4000
      });
    }
  }

  // ì••ì¶• ê¸°ë°˜ íŒŒì¼ ì—…ë¡œë“œ í•¨ìˆ˜ (ì‚¬ìš© ì•ˆí•¨)

  // ì¼ë°˜ íŒŒì¼ë“¤ì„ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
  async function handleDropFiles(files: File[], targetFolderId: string | null) {
    console.log('ì¼ë°˜ íŒŒì¼ ì—…ë¡œë“œ ì‹œì‘:', files.length);
    
    for (const file of files) {
      try {
        // íŒŒì¼ ë‚´ìš©ì„ ArrayBufferë¡œ ì½ê¸°
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        
        // íŒŒì¼ì´ í…ìŠ¤íŠ¸ íŒŒì¼ì¸ì§€ í™•ì¸ (ê°„ë‹¨í•œ íœ´ë¦¬ìŠ¤í‹±)
        const isTextFile = isLikelyTextFile(file.name, uint8Array);
        
        const { invoke } = await import('@tauri-apps/api/core');
        
        if (isTextFile) {
          // í…ìŠ¤íŠ¸ íŒŒì¼ë¡œ ì²˜ë¦¬
          try {
            const content = new TextDecoder('utf-8').decode(uint8Array);
            await invoke('create_new_file_in_vault', {
              folderId: targetFolderId,
              fileName: file.name,
              content: content
            });
          } catch (decodeError) {
            // UTF-8 ë””ì½”ë”© ì‹¤íŒ¨ ì‹œ ë°”ì´ë„ˆë¦¬ë¡œ ì²˜ë¦¬
            const base64Content = await arrayBufferToBase64(arrayBuffer);
            await invoke('create_binary_file_in_vault', {
              folderId: targetFolderId,
              fileName: file.name,
              content: base64Content
            });
          }
        } else {
          // ë°”ì´ë„ˆë¦¬ íŒŒì¼ë¡œ ì²˜ë¦¬
          const base64Content = await arrayBufferToBase64(arrayBuffer);
          await invoke('create_binary_file_in_vault', {
            folderId: targetFolderId,
            fileName: file.name,
            content: base64Content
          });
        }
        
        console.log('íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ:', file.name);
        
      } catch (error) {
        console.error('íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:', file.name, error);
        addToast({
          type: 'error',
          title: 'íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨',
          message: `'${file.name}' íŒŒì¼ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${error}`,
          duration: 5000
        });
      }
    }
  }

  // ArrayBufferë¥¼ ì•ˆì „í•˜ê²Œ base64ë¡œ ì¸ì½”ë”©í•˜ëŠ” í•¨ìˆ˜ (Promise ê¸°ë°˜)
  async function arrayBufferToBase64(buffer: ArrayBuffer): Promise<string> {
    // íŒŒì¼ í¬ê¸° ì œí•œ í™•ì¸ (1GB)
    const maxSize = 1024 * 1024 * 1024; // 1GB
    if (buffer.byteLength > maxSize) {
      throw new Error(`íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤. ìµœëŒ€ 1GBê¹Œì§€ ì§€ì›ë©ë‹ˆë‹¤. (í˜„ì¬: ${(buffer.byteLength / 1024 / 1024).toFixed(1)}MB)`);
    }
    
    console.log(`Base64 ë³€í™˜ ì‹œì‘: ${buffer.byteLength} bytes`);
    
    // ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ base64 ë³€í™˜ (FileReader ì‚¬ìš©)
    return new Promise((resolve, reject) => {
      try {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const result = reader.result;
            console.log('FileReader ê²°ê³¼ íƒ€ì…:', typeof result);
            
            if (typeof result !== 'string') {
              reject(new Error('FileReader ê²°ê³¼ê°€ ë¬¸ìì—´ì´ ì•„ë‹™ë‹ˆë‹¤.'));
              return;
            }
            
            // data:application/octet-stream;base64, ë˜ëŠ” data:;base64, í˜•íƒœ í™•ì¸
            const base64Prefix = 'base64,';
            const base64Index = result.indexOf(base64Prefix);
            
            if (base64Index === -1) {
              console.error('Base64 ì ‘ë‘ì‚¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ. ì „ì²´ ê²°ê³¼:', result.substring(0, 200));
              reject(new Error('Base64 ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'));
              return;
            }
            
            const base64 = result.substring(base64Index + base64Prefix.length);
            if (!base64 || base64.length === 0) {
              console.error('Base64 ë°ì´í„°ê°€ ë¹„ì–´ìˆìŒ');
              reject(new Error('Base64 ë³€í™˜ ê²°ê³¼ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.'));
              return;
            }
            
            console.log(`Base64 ë³€í™˜ ì„±ê³µ: ${buffer.byteLength} bytes -> ${base64.length} chars`);
            resolve(base64);
          } catch (error) {
            console.error('Base64 ë³€í™˜ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
            reject(new Error(`Base64 ë³€í™˜ ì¤‘ ì˜¤ë¥˜: ${error}`));
          }
        };
        reader.onerror = () => {
          console.error('FileReader ì˜¤ë¥˜:', reader.error);
          reject(new Error(`FileReader ì˜¤ë¥˜: ${reader.error?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`));
        };
        
        reader.readAsDataURL(new Blob([buffer]));
      } catch (error) {
        console.error('Base64 ë³€í™˜ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
        reject(new Error(`Base64 ë³€í™˜ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error}`));
      }
    });
  }

  // í° íŒŒì¼ì„ ì²­í¬ ë‹¨ìœ„ë¡œ base64 ë³€í™˜í•˜ëŠ” í•¨ìˆ˜ (ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹)
  async function arrayBufferToBase64Chunked(buffer: ArrayBuffer, chunkSize: number): Promise<string> {
    // ë§¤ìš° í° íŒŒì¼ì˜ ê²½ìš° ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œ ì‚¬ìš©
    const maxDirectProcessingSize = 500 * 1024 * 1024; // 500MB
    if (buffer.byteLength > maxDirectProcessingSize) {
      throw new Error(`íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤ (${(buffer.byteLength / 1024 / 1024).toFixed(1)}MB). ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.`);
    }
    
    // ë¬¸ìì—´ ê¸¸ì´ ì œí•œì„ í”¼í•˜ê¸° ìœ„í•´ ë” ì‘ì€ ì²­í¬ ì‚¬ìš©
    const safeChunkSize = Math.min(chunkSize, 10 * 1024 * 1024); // ìµœëŒ€ 10MB ì²­í¬ë¡œ ì¦ê°€
    const chunks: string[] = [];
    const totalChunks = Math.ceil(buffer.byteLength / safeChunkSize);
    
    console.log(`ì²­í¬ ë‹¨ìœ„ ë³€í™˜: ${totalChunks}ê°œ ì²­í¬ë¡œ ë¶„í•  (ì²­í¬ í¬ê¸°: ${(safeChunkSize / 1024 / 1024).toFixed(1)}MB)`);
    
    // ë„ˆë¬´ ë§ì€ ì²­í¬ê°€ ìƒì„±ë˜ë©´ ì—ëŸ¬ ë°œìƒ
    if (totalChunks > 300) {
      throw new Error(`íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤. ì²­í¬ ìˆ˜ê°€ ${totalChunks}ê°œë¡œ ì œí•œì„ ì´ˆê³¼í•©ë‹ˆë‹¤. (ìµœëŒ€ 300ê°œ ì²­í¬ ì§€ì›)`);
    }
    
    for (let i = 0; i < totalChunks; i++) {
      const start = i * safeChunkSize;
      const end = Math.min(start + safeChunkSize, buffer.byteLength);
      const chunk = buffer.slice(start, end);
      
      console.log(`ì²­í¬ ${i + 1}/${totalChunks} ì²˜ë¦¬ ì¤‘ (${(start / 1024 / 1024).toFixed(1)}MB-${(end / 1024 / 1024).toFixed(1)}MB)`);
      
      try {
        const chunkBase64 = await new Promise<string>((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            const result = reader.result as string;
            const base64Index = result.indexOf('base64,');
            if (base64Index === -1) {
              reject(new Error(`ì²­í¬ ${i + 1}ì—ì„œ Base64 ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`));
              return;
            }
            const base64 = result.substring(base64Index + 7);
            resolve(base64);
          };
          reader.onerror = () => reject(new Error(`ì²­í¬ ${i + 1} ì½ê¸° ì‹¤íŒ¨`));
          reader.readAsDataURL(new Blob([chunk]));
        });
        
        chunks.push(chunkBase64);
        
        // ë©”ëª¨ë¦¬ ì••ë°•ì„ ì¤„ì´ê¸° ìœ„í•´ ì¤‘ê°„ì— ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ íŒíŠ¸
        if (i % 10 === 0 && i > 0) {
          // ì ì‹œ ëŒ€ê¸°í•˜ì—¬ ë¸Œë¼ìš°ì €ê°€ ë©”ëª¨ë¦¬ë¥¼ ì •ë¦¬í•  ì‹œê°„ì„ ì¤Œ
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      } catch (error) {
        console.error(`ì²­í¬ ${i + 1} ì²˜ë¦¬ ì‹¤íŒ¨:`, error);
        throw new Error(`ì²­í¬ ${i + 1} Base64 ë³€í™˜ ì‹¤íŒ¨: ${error}`);
      }
    }
    
    console.log(`ì²­í¬ ê²°í•© ì‹œì‘: ${chunks.length}ê°œ ì²­í¬`);
    
    // ì²­í¬ë“¤ì„ ì•ˆì „í•˜ê²Œ ê²°í•© - ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë°©ë²• ì‚¬ìš©
    try {
      // ì‘ì€ ë°°ì¹˜ë¡œ ë‚˜ëˆ„ì–´ ê²°í•©í•˜ì—¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¤„ì´ê¸°
      const batchSize = 20; // 20ê°œì”© ë°°ì¹˜ë¡œ ì²˜ë¦¬
      let result = '';
      
      for (let i = 0; i < chunks.length; i += batchSize) {
        const batch = chunks.slice(i, i + batchSize);
        const batchResult = batch.join('');
        result += batchResult;
        
        // ë°°ì¹˜ ì²˜ë¦¬ í›„ ì ì‹œ ëŒ€ê¸°
        if (i + batchSize < chunks.length) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      console.log(`ì²­í¬ ë‹¨ìœ„ ë³€í™˜ ì™„ë£Œ: ${buffer.byteLength} bytes -> ${result.length} chars`);
      return result;
    } catch (joinError) {
      console.error('ì²­í¬ ê²°í•© ì‹¤íŒ¨:', joinError);
      throw new Error(`ì²­í¬ ê²°í•© ì‹¤íŒ¨: ë¸Œë¼ìš°ì € ë©”ëª¨ë¦¬ ì œí•œì— ê±¸ë ¸ìŠµë‹ˆë‹¤. íŒŒì¼ í¬ê¸°ë¥¼ ì¤„ì—¬ì£¼ì„¸ìš”.`);
    }
  }

  // ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ í° íŒŒì¼ì„ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
  async function uploadFileWithStreaming(file: File, folderId: string | null): Promise<void> {
    const { invoke } = await import('@tauri-apps/api/core');
    
    console.log(`ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œ ì‹œì‘: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
    
    // ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œ ì§„í–‰ë¥  ì‹œì‘ (ì´ë¯¸ startUploadê°€ í˜¸ì¶œë˜ì§€ ì•Šì€ ê²½ìš°)
    if (!$isUploading) {
      startUpload([file.name]);
    }
    
    let sessionId: string | null = null;
    
    try {
      // 1. ì—…ë¡œë“œ ì„¸ì…˜ ì‹œì‘
      sessionId = await invoke('start_chunked_upload', {
        fileName: file.name,
        fileSize: file.size,
        folderId: folderId
      }) as string;
      
      console.log(`ì—…ë¡œë“œ ì„¸ì…˜ ìƒì„±: ${sessionId}`);
      setUploadSession(file.name, sessionId);
      
      // 2. íŒŒì¼ì„ ì²­í¬ë¡œ ë‚˜ëˆ„ì–´ ì—…ë¡œë“œ
      const chunkSize = 10 * 1024 * 1024; // 10MB ì²­í¬
      const totalChunks = Math.ceil(file.size / chunkSize);
      let uploadedChunks = 0;
      
      for (let i = 0; i < totalChunks; i++) {
        const start = i * chunkSize;
        const end = Math.min(start + chunkSize, file.size);
        const chunk = file.slice(start, end);
        const isLastChunk = i === totalChunks - 1;
        
        // ì²­í¬ë¥¼ ArrayBufferë¡œ ì½ê¸°
        const chunkBuffer = await chunk.arrayBuffer();
        
        // Base64ë¡œ ì¸ì½”ë”©
        const chunkBase64 = await new Promise<string>((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            const result = reader.result as string;
            const base64Index = result.indexOf('base64,');
            if (base64Index === -1) {
              reject(new Error('Base64 ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'));
              return;
            }
            resolve(result.substring(base64Index + 7));
          };
          reader.onerror = () => reject(new Error('ì²­í¬ ì½ê¸° ì‹¤íŒ¨'));
          reader.readAsDataURL(new Blob([chunkBuffer]));
        });
        
        // ì²­í¬ ì—…ë¡œë“œ (ë§ˆì§€ë§‰ ì²­í¬ëŠ” íƒ€ì„ì•„ì›ƒì„ ë” ê¸¸ê²Œ, ìµœëŒ€ 2ë¶„ìœ¼ë¡œ ì œí•œ)
        const baseTimeout = 120000; // ê¸°ë³¸ 2ë¶„
        const lastChunkTimeout = 120000; // ë§ˆì§€ë§‰ ì²­í¬ë„ 2ë¶„ìœ¼ë¡œ ì œí•œ (ê³ ì† ì²˜ë¦¬)
        const uploadTimeout = isLastChunk ? lastChunkTimeout : baseTimeout;
        
        console.log(`ì²­í¬ ${i + 1}/${totalChunks} ì—…ë¡œë“œ ì‹œì‘ (í¬ê¸°: ${(chunk.size / 1024 / 1024).toFixed(1)}MB, ë§ˆì§€ë§‰: ${isLastChunk}, íƒ€ì„ì•„ì›ƒ: ${uploadTimeout/1000/60}ë¶„)`);
        
        if (isLastChunk) {
          console.log('ë§ˆì§€ë§‰ ì²­í¬ ì²˜ë¦¬ ì‹œì‘ - ê³ ì† íŒŒì¼ ì¡°ë¦½, ì•”í˜¸í™” ì§„í–‰ ì¤‘...');
          console.log(`ì˜ˆìƒ ì²˜ë¦¬ ì‹œê°„: 2ë¶„ ì´ë‚´`);
          updateUploadProgress(file.name, 95); // ë§ˆì§€ë§‰ ì²­í¬ ì‹œì‘ ì‹œ 95%ë¡œ í‘œì‹œ
        }
        
        const isComplete = await Promise.race([
          invoke('upload_file_chunk', {
            sessionId: sessionId,
            chunkIndex: i,
            chunkData: chunkBase64,
            isLastChunk: isLastChunk
          }) as Promise<boolean>,
          new Promise<never>((_, reject) => 
            setTimeout(() => reject(new Error(`ì²­í¬ ì—…ë¡œë“œ íƒ€ì„ì•„ì›ƒ (${(uploadTimeout/1000/60).toFixed(1)}ë¶„)`)), uploadTimeout)
          )
        ]);
        
        uploadedChunks++;
        let progress = (uploadedChunks / totalChunks) * 100;
        
        if (isLastChunk) {
          if (isComplete) {
            console.log(`ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œ ì™„ë£Œ: ${file.name}`);
            progress = 100;
            updateUploadProgress(file.name, progress);
            console.log('íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ!');
            break;
          } else {
            // ë§ˆì§€ë§‰ ì²­í¬ê°€ ì•„ì§ ì²˜ë¦¬ ì¤‘ (ì´ ê²½ìš°ëŠ” ë°œìƒí•˜ì§€ ì•Šì•„ì•¼ í•¨)
            progress = Math.min(99.9, progress);
            console.log(`ë§ˆì§€ë§‰ ì²­í¬ ì²˜ë¦¬ ì¤‘... (${progress.toFixed(1)}%)`);
          }
        } else {
          console.log(`ì²­í¬ ${i + 1}/${totalChunks} ì—…ë¡œë“œ ì™„ë£Œ (${progress.toFixed(1)}%)`);
        }
        
        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ (UIì— í‘œì‹œ)
        updateUploadProgress(file.name, progress);
        
        // ë§ˆì§€ë§‰ ì²­í¬ê°€ ì™„ë£Œë˜ë©´ ë£¨í”„ ì¢…ë£Œ
        if (isComplete && isLastChunk) {
          break;
        }
        
        // ì„œë²„ ë¶€í•˜ë¥¼ ì¤„ì´ê¸° ìœ„í•´ ì ì‹œ ëŒ€ê¸° (ë§ˆì§€ë§‰ ì²­í¬ê°€ ì•„ë‹Œ ê²½ìš°ë§Œ)
        if (!isLastChunk) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      // íŒŒì¼ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
      await FileManagerService.refresh();
      
    } catch (error) {
      console.error('ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œ ì‹¤íŒ¨:', error);
      
      // ì§„í–‰ë¥ ì—ì„œ ì‹¤íŒ¨í•œ íŒŒì¼ ì œê±°
      handleUploadError(file.name);
      
      // ì—…ë¡œë“œ ì·¨ì†Œ
      if (sessionId) {
        try {
          await invoke('cancel_chunked_upload', { sessionId: sessionId });
        } catch (cancelError) {
          console.error('ì—…ë¡œë“œ ì·¨ì†Œ ì‹¤íŒ¨:', cancelError);
        }
      }
      
      throw error;
    }
  }

  // ì—…ë¡œë“œ ì§„í–‰ë¥ ì„ ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜
  function updateUploadProgress(fileName: string, progress: number) {
    uploadProgress.update(progressMap => {
      const newMap = new Map(progressMap);
      newMap.set(fileName, progress);
      return newMap;
    });
    
    console.log(`ì—…ë¡œë“œ ì§„í–‰ë¥ : ${fileName} - ${progress.toFixed(1)}%`);
    
    // ëª¨ë“  íŒŒì¼ ì—…ë¡œë“œê°€ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
    uploadProgress.subscribe(progressMap => {
      const allCompleted = Array.from(progressMap.values()).every(p => p >= 100);
      if (allCompleted && progressMap.size > 0) {
        // ì ì‹œ í›„ ì§„í–‰ë¥  í‘œì‹œ ì œê±°
        setTimeout(() => {
          uploadProgress.set(new Map());
          currentUploadSessions.set(new Map());
          isUploading.set(false);
        }, 2000);
      }
    })();
  }

  // ì—…ë¡œë“œ ì‹œì‘ ì‹œ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜
  function startUpload(fileNames: string[]) {
    isUploading.set(true);
    const progressMap = new Map<string, number>();
    const sessionMap = new Map<string, string>();
    fileNames.forEach(name => {
      progressMap.set(name, 0);
      sessionMap.set(name, ''); // ì„¸ì…˜ IDëŠ” ë‚˜ì¤‘ì— ì„¤ì •
    });
    uploadProgress.set(progressMap);
    currentUploadSessions.set(sessionMap);
  }

  // ì—…ë¡œë“œ ì„¸ì…˜ ID ì„¤ì •
  function setUploadSession(fileName: string, sessionId: string) {
    currentUploadSessions.update(sessionMap => {
      const newMap = new Map(sessionMap);
      newMap.set(fileName, sessionId);
      return newMap;
    });
  }

  // ì—…ë¡œë“œ ì·¨ì†Œ í•¨ìˆ˜
  async function cancelUpload(fileName?: string) {
    const { invoke } = await import('@tauri-apps/api/core');
    
    try {
      if (fileName) {
        // íŠ¹ì • íŒŒì¼ ì—…ë¡œë“œ ì·¨ì†Œ
        const sessions = $currentUploadSessions;
        const sessionId = sessions.get(fileName);
        if (sessionId) {
          await invoke('cancel_chunked_upload', { sessionId });
          console.log(`ì—…ë¡œë“œ ì·¨ì†Œë¨: ${fileName}`);
        }
        
        // ì§„í–‰ë¥ ì—ì„œ ì œê±°
        uploadProgress.update(progressMap => {
          const newMap = new Map(progressMap);
          newMap.delete(fileName);
          return newMap;
        });
        
        currentUploadSessions.update(sessionMap => {
          const newMap = new Map(sessionMap);
          newMap.delete(fileName);
          return newMap;
        });
      } else {
        // ëª¨ë“  ì—…ë¡œë“œ ì·¨ì†Œ
        const sessions = $currentUploadSessions;
        for (const [fileName, sessionId] of sessions.entries()) {
          if (sessionId) {
            try {
              await invoke('cancel_chunked_upload', { sessionId });
              console.log(`ì—…ë¡œë“œ ì·¨ì†Œë¨: ${fileName}`);
            } catch (error) {
              console.error(`ì—…ë¡œë“œ ì·¨ì†Œ ì‹¤íŒ¨ (${fileName}):`, error);
            }
          }
        }
        
        // ëª¨ë“  ì§„í–‰ë¥  ì´ˆê¸°í™”
        uploadProgress.set(new Map());
        currentUploadSessions.set(new Map());
        isUploading.set(false);
      }
      
      addToast({
        type: 'info',
        title: 'ì—…ë¡œë“œ ì·¨ì†Œ',
        message: 'ì—…ë¡œë“œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.',
        duration: 3000
      });
    } catch (error) {
      console.error('ì—…ë¡œë“œ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜:', error);
      addToast({
        type: 'error',
        title: 'ì—…ë¡œë“œ ì·¨ì†Œ ì‹¤íŒ¨',
        message: 'ì—…ë¡œë“œ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
        duration: 5000
      });
    }
  }

  // ì—…ë¡œë“œ ì‹¤íŒ¨ ì‹œ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜
  function handleUploadError(fileName: string) {
    uploadProgress.update(progressMap => {
      const newMap = new Map(progressMap);
      newMap.delete(fileName);
      return newMap;
    });
    
    currentUploadSessions.update(sessionMap => {
      const newMap = new Map(sessionMap);
      newMap.delete(fileName);
      return newMap;
    });
  }

  // íŒŒì¼ì´ í…ìŠ¤íŠ¸ íŒŒì¼ì¸ì§€ íŒë‹¨í•˜ëŠ” í•¨ìˆ˜
  function isLikelyTextFile(fileName: string, data: Uint8Array): boolean {
    // í™•ì¥ì ê¸°ë°˜ íŒë‹¨
    const textExtensions = [
      'txt', 'md', 'json', 'xml', 'csv', 'html', 'css', 'js', 'ts', 
      'py', 'cs', 'java', 'cpp', 'c', 'h', 'sql', 'yaml', 'yml', 
      'ini', 'log', 'conf', 'config', 'sh', 'bat', 'ps1'
    ];
    
    const extension = fileName.split('.').pop()?.toLowerCase();
    if (extension && textExtensions.includes(extension)) {
      return true;
    }
    
    // ë°”ì´ë„ˆë¦¬ ì‹œê·¸ë‹ˆì²˜ í™•ì¸ (ì²˜ìŒ ëª‡ ë°”ì´íŠ¸)
    if (data.length === 0) return true;
    
    // ì¼ë°˜ì ì¸ ë°”ì´ë„ˆë¦¬ íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ë“¤
    const binarySignatures = [
      [0xFF, 0xD8, 0xFF], // JPEG
      [0x89, 0x50, 0x4E, 0x47], // PNG
      [0x47, 0x49, 0x46], // GIF
      [0x25, 0x50, 0x44, 0x46], // PDF
      [0x50, 0x4B, 0x03, 0x04], // ZIP
      [0x50, 0x4B, 0x05, 0x06], // ZIP (empty)
      [0x50, 0x4B, 0x07, 0x08], // ZIP (spanned)
      [0x52, 0x61, 0x72, 0x21], // RAR
      [0x7F, 0x45, 0x4C, 0x46], // ELF
      [0x4D, 0x5A], // PE/EXE
    ];
    
    for (const signature of binarySignatures) {
      if (data.length >= signature.length) {
        let matches = true;
        for (let i = 0; i < signature.length; i++) {
          if (data[i] !== signature[i]) {
            matches = false;
            break;
          }
        }
        if (matches) return false; // ë°”ì´ë„ˆë¦¬ íŒŒì¼
      }
    }
    
    // ì²˜ìŒ 1KB ë‚´ì—ì„œ null ë°”ì´íŠ¸ë‚˜ ì œì–´ ë¬¸ì ë¹„ìœ¨ í™•ì¸
    const sampleSize = Math.min(1024, data.length);
    let controlChars = 0;
    
    for (let i = 0; i < sampleSize; i++) {
      const byte = data[i];
      // null ë°”ì´íŠ¸ë‚˜ ë¹„ì •ìƒì ì¸ ì œì–´ ë¬¸ì
      if (byte === 0 || (byte < 32 && byte !== 9 && byte !== 10 && byte !== 13)) {
        controlChars++;
      }
    }
    
    // ì œì–´ ë¬¸ìê°€ 30% ì´ìƒì´ë©´ ë°”ì´ë„ˆë¦¬ë¡œ íŒë‹¨
    const controlRatio = controlChars / sampleSize;
    return controlRatio < 0.3;
  }

  // í´ë”ë“¤ì„ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
  async function handleDropFolders(folderEntries: FileSystemEntry[], targetFolderId: string | null) {
    console.log('í´ë” ì—…ë¡œë“œ ì‹œì‘:', folderEntries.length);
    
    for (const entry of folderEntries) {
      try {
        // í´ë” êµ¬ì¡°ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì½ì–´ì„œ ì²˜ë¦¬
        await processDirectoryEntry(entry as FileSystemDirectoryEntry, targetFolderId);
        console.log('í´ë” ì—…ë¡œë“œ ì™„ë£Œ:', entry.name);
        
      } catch (error) {
        console.error('í´ë” ì—…ë¡œë“œ ì‹¤íŒ¨:', entry.name, error);
        addToast({
          type: 'error',
          title: 'í´ë” ì—…ë¡œë“œ ì‹¤íŒ¨',
          message: `'${entry.name}' í´ë” ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${error}`,
          duration: 5000
        });
      }
    }
  }

  // ë””ë ‰í† ë¦¬ ì—”íŠ¸ë¦¬ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
  async function processDirectoryEntry(dirEntry: FileSystemDirectoryEntry, parentFolderId: string | null): Promise<string> {
    const { invoke } = await import('@tauri-apps/api/core');
    
    // ë¨¼ì € í´ë”ë¥¼ ìƒì„±
    const folderEntry = await invoke('create_folder', {
      name: dirEntry.name,
      parent_id: parentFolderId
    }) as any;
    
    const newFolderId = folderEntry.id;
    console.log('í´ë” ìƒì„±ë¨:', dirEntry.name, 'ID:', newFolderId);
    
    // í´ë” ë‚´ìš©ì„ ì½ê¸°
    const reader = dirEntry.createReader();
    
    return new Promise((resolve, reject) => {
      const readEntries = () => {
        reader.readEntries(async (entries) => {
          if (entries.length === 0) {
            // ëª¨ë“  ì—”íŠ¸ë¦¬ë¥¼ ì½ì—ˆìŒ
            resolve(newFolderId);
            return;
          }
          
          try {
            // ê° ì—”íŠ¸ë¦¬ë¥¼ ì²˜ë¦¬
            for (const entry of entries) {
              if (entry.isFile) {
                // íŒŒì¼ ì²˜ë¦¬
                const fileEntry = entry as FileSystemFileEntry;
                await processFileEntry(fileEntry, newFolderId);
              } else if (entry.isDirectory) {
                // í•˜ìœ„ í´ë” ì¬ê·€ ì²˜ë¦¬
                const subDirEntry = entry as FileSystemDirectoryEntry;
                await processDirectoryEntry(subDirEntry, newFolderId);
              }
            }
            
            // ë” ë§ì€ ì—”íŠ¸ë¦¬ê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê³„ì† ì½ê¸°
            readEntries();
            
          } catch (error) {
            reject(error);
          }
        }, reject);
      };
      
      readEntries();
    });
  }

  // íŒŒì¼ ì—”íŠ¸ë¦¬ë¥¼ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
  async function processFileEntry(fileEntry: FileSystemFileEntry, folderId: string) {
    return new Promise<void>((resolve, reject) => {
      fileEntry.file(async (file) => {
        try {
          // íŒŒì¼ ë‚´ìš© ì½ê¸°
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          
          // íŒŒì¼ì´ í…ìŠ¤íŠ¸ íŒŒì¼ì¸ì§€ í™•ì¸
          const isTextFile = isLikelyTextFile(file.name, uint8Array);
          
          const { invoke } = await import('@tauri-apps/api/core');
          
          if (isTextFile) {
            // í…ìŠ¤íŠ¸ íŒŒì¼ë¡œ ì²˜ë¦¬
            try {
              const content = new TextDecoder('utf-8').decode(uint8Array);
              await invoke('create_new_file_in_vault', {
                folderId: folderId,
                fileName: file.name,
                content: content
              });
            } catch (decodeError) {
              // UTF-8 ë””ì½”ë”© ì‹¤íŒ¨ ì‹œ ë°”ì´ë„ˆë¦¬ë¡œ ì²˜ë¦¬
              const base64Content = await arrayBufferToBase64(arrayBuffer);
              await invoke('create_binary_file_in_vault', {
                folderId: folderId,
                fileName: file.name,
                content: base64Content
              });
            }
          } else {
            // ë°”ì´ë„ˆë¦¬ íŒŒì¼ë¡œ ì²˜ë¦¬
            const base64Content = await arrayBufferToBase64(arrayBuffer);
            await invoke('create_binary_file_in_vault', {
              folderId: folderId,
              fileName: file.name,
              content: base64Content
            });
          }
          
          console.log('íŒŒì¼ ìƒì„±ë¨:', file.name, 'í´ë” ID:', folderId);
          resolve();
          
        } catch (error) {
          reject(error);
        }
      }, reject);
    });
  }
</script>

<svelte:window onkeydown={handleKeyDown} />

<svelte:head>
  <title>íŒŒì¼ ë§¤ë‹ˆì € - SecureVault</title>
</svelte:head>

<!-- ë©”ì¸ ë ˆì´ì•„ì›ƒ -->
<div 
  class="file-manager h-screen flex flex-col bg-gray-50"
  class:drag-over={isDragOver}
  role="application"
  aria-label="íŒŒì¼ ë§¤ë‹ˆì € ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜ì—­"
  on:dragover={handleDragOverDirect}
  on:dragleave={handleDragLeaveDirect}
  on:drop={handleDropDirect}
>
  <!-- ì»¤ìŠ¤í…€ íƒ€ì´í‹€ë°” -->
  <TitleBar 
    title="SecureVault" 
    subtitle="íŒŒì¼ ë§¤ë‹ˆì €"
    showIcon={true}
    showTitle={true}
    variant="gradient"
  />

  <!-- íˆ´ë°” -->
  <Toolbar 
    onAddFile={handleAddFile}
    onAddFolder={handleAddFolder}
    onCreateFile={handleCreateFile}
    onCreateFolder={handleCreateFolder}
    onDeleteSelected={handleDeleteSelected}
    onExportSelected={handleExportSelected}
    onRenameSelected={handleRenameSelected}
    hasSelection={hasSelectedItems}
    selectionCount={selectionCount}
    hasFileSelection={hasFileSelectionState}
    selectedFileCount={selectedFileCountState}
  />

  <!-- ì—ëŸ¬ ë©”ì‹œì§€ -->
  {#if error}
    <div class="error-banner bg-red-50 border-l-4 border-red-400 p-4 mx-4 mt-2">
      <div class="flex items-center justify-between">
        <div class="flex items-center">
          <svg class="w-5 h-5 text-red-400 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
          </svg>
          <p class="text-sm text-red-700 text-korean">{error}</p>
        </div>
        <button 
          class="text-red-400 hover:text-red-600"
          on:click={handleCloseError}
          title="ë‹«ê¸°"
        >
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
    </div>
  {/if}

  <!-- ë©”ì¸ ì½˜í…ì¸  ì˜ì—­ -->
  <div class="flex-1 flex overflow-hidden">
    <!-- ì™¼ìª½: í´ë” íŠ¸ë¦¬ -->
    <div class="folder-tree-panel w-64 bg-white border-r border-gray-200 flex-shrink-0">
      <div class="p-4 border-b border-gray-200">
        <h3 class="text-sm font-medium text-gray-900 text-korean">í´ë”</h3>
      </div>
      <div class="flex-1 overflow-auto">
        <FolderTree />
      </div>
    </div>

    <!-- ì˜¤ë¥¸ìª½: íŒŒì¼ ëª©ë¡ -->
    <div class="file-list-panel flex-1 flex flex-col bg-white">
      <!-- ê²½ë¡œ í‘œì‹œ -->
      <div class="path-bar p-4 border-b border-gray-200 bg-gray-50">
        <div class="flex items-center text-sm text-gray-600">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2H5a2 2 0 00-2 2z"/>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                  d="M8 5a2 2 0 012-2h4a2 2 0 012 2v2H8V5z"/>
          </svg>
          <span class="text-korean">í˜„ì¬ ìœ„ì¹˜:</span>
          <span class="ml-2 font-mono">{folderPath}</span>
        </div>
      </div>

      <!-- íŒŒì¼ ëª©ë¡ -->
      <div class="flex-1 overflow-auto relative">
        {#if isLoading}
          <!-- ë¡œë”© ìƒíƒœ -->
          <div class="flex items-center justify-center h-64">
            <div class="text-center">
              <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
              <p class="text-sm text-gray-600 text-korean">íŒŒì¼ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>
            </div>
          </div>
        {:else}
          <FileList />
        {/if}

        <!-- ì—…ë¡œë“œ ì§„í–‰ë¥  í‘œì‹œ -->
        {#if $isUploading && $uploadProgress.size > 0}
          <div class="upload-progress-overlay absolute top-4 right-4 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg p-4 z-40 min-w-80 max-w-md">
            <div class="flex items-center justify-between mb-3">
              <h4 class="text-sm font-medium text-gray-900 dark:text-gray-100 text-korean">íŒŒì¼ ì—…ë¡œë“œ ì§„í–‰ë¥ </h4>
              <div class="text-xs text-gray-500 dark:text-gray-400 text-korean">
                {Array.from($uploadProgress.values()).filter(p => p >= 100).length} / {$uploadProgress.size} ì™„ë£Œ
              </div>
            </div>
            
            <div class="space-y-3 max-h-64 overflow-y-auto">
              {#each Array.from($uploadProgress.entries()) as [fileName, progress]}
                <div class="upload-item">
                  <ProgressBar 
                    {progress}
                    label={fileName}
                    showPercentage={true}
                    showCancel={progress < 100}
                    color={progress >= 100 ? 'success' : 'primary'}
                    size="small"
                    animated={progress < 100}
                    on:cancel={() => cancelUpload(fileName)}
                  >
                    <div slot="details">
                      {#if progress >= 100}
                        <div class="flex items-center mt-1">
                          <svg class="w-3 h-3 text-green-600 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                          </svg>
                          <span class="text-xs text-green-600 text-korean">ì—…ë¡œë“œ ì™„ë£Œ</span>
                        </div>
                      {:else if progress > 90}
                        <div class="text-xs text-blue-600 text-korean mt-1">
                          íŒŒì¼ ì²˜ë¦¬ ì¤‘... (ì•”í˜¸í™” ë° ì••ì¶•)
                        </div>
                      {/if}
                    </div>
                  </ProgressBar>
                </div>
              {/each}
            </div>
            
            <!-- ì „ì²´ ì§„í–‰ë¥  -->
            {#if $uploadProgress.size > 1}
              {@const totalProgress = Array.from($uploadProgress.values()).reduce((sum, p) => sum + p, 0) / $uploadProgress.size}
              <div class="mt-4 pt-3 border-t border-gray-200 dark:border-gray-600">
                <ProgressBar 
                  progress={totalProgress}
                  label="ì „ì²´ ì§„í–‰ë¥ "
                  showPercentage={true}
                  color={totalProgress >= 100 ? 'success' : 'primary'}
                  size="medium"
                  animated={totalProgress < 100}
                />
              </div>
            {/if}
            
            <!-- ì „ì²´ ì·¨ì†Œ ë²„íŠ¼ -->
            <div class="mt-3 flex justify-end">
              <button
                type="button"
                class="text-xs text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-200 transition-colors px-2 py-1 rounded hover:bg-red-50 dark:hover:bg-red-900/20"
                on:click={() => cancelUpload()}
              >
                ëª¨ë“  ì—…ë¡œë“œ ì·¨ì†Œ
              </button>
            </div>
          </div>
        {/if}

        <!-- ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜¤ë²„ë ˆì´ -->
        {#if isDragOver}
          <div class="drag-overlay fixed inset-0 bg-blue-500 bg-opacity-30 border-4 border-dashed border-blue-500 flex items-center justify-center z-[9999] pointer-events-none">
            <div class="text-center pointer-events-none bg-white bg-opacity-90 p-8 rounded-lg shadow-lg">
              <svg class="w-20 h-20 text-blue-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                      d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
              </svg>
              <p class="text-xl font-bold text-blue-700 text-korean mb-2">íŒŒì¼ê³¼ í´ë”ë¥¼ ì—¬ê¸°ì— ë“œë¡­í•˜ì„¸ìš”</p>
              <p class="text-base text-blue-600 text-korean">ì—¬ëŸ¬ íŒŒì¼ê³¼ í´ë”ë¥¼ ë™ì‹œì— ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
            </div>
          </div>
        {/if}
      </div>
    </div>
  </div>

  <!-- ìƒíƒœ í‘œì‹œì¤„ -->
  <StatusBar />

  <!-- ìƒˆ íŒŒì¼ ìƒì„± ë‹¤ì´ì–¼ë¡œê·¸ -->
  <NewFileDialog 
    isOpen={showNewFileDialog}
    onCreate={handleNewFileCreate}
    onCancel={handleNewFileCancel}
  />

  <!-- íŒŒì¼ ë‚´ë³´ë‚´ê¸° ë‹¤ì´ì–¼ë¡œê·¸ -->
  {#if showExportDialog}
    <ExportDialog 
      isOpen={showExportDialog}
      selectedFiles={$fileManagerState.files.filter(file => $fileManagerState.selection.selectedFiles.has(file.id))}
      selectedFolders={$fileManagerState.folders.filter(folder => $fileManagerState.selection.selectedFolders.has(folder.id))}
      onExport={(data) => {
        handleExportComplete({ detail: data } as CustomEvent<{ files: any[]; folders: any[]; exportPath: string }>);
      }}
      onCancel={() => {
        handleExportCancel();
      }}
    />
  {/if}

  <!-- ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ -->
  {#if showDeleteConfirmDialog}
    <DeleteConfirmDialog 
      isOpen={showDeleteConfirmDialog}
      selectedFiles={$fileManagerState.files.filter(file => $fileManagerState.selection.selectedFiles.has(file.id))}
      selectedFolders={$fileManagerState.folders.filter(folder => $fileManagerState.selection.selectedFolders.has(folder.id))}
      onConfirm={() => {
        handleDeleteConfirm();
      }}
      onCancel={() => {
        handleDeleteCancel();
      }}
    />
  {/if}

  <!-- í´ë” ìƒì„± ë‹¤ì´ì–¼ë¡œê·¸ -->
  {#if showCreateFolderDialog}
    <CreateFolderDialog 
      isOpen={showCreateFolderDialog}
      onConfirm={(folderName) => {
        handleCreateFolderConfirm(folderName);
      }}
      onCancel={() => {
        handleCreateFolderCancel();
      }}
    />
  {/if}

  <!-- íŒŒì¼ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ -->
  {#if showAddFileDialog}
    <AddFileDialog 
      isOpen={showAddFileDialog}
      onConfirm={(folderId) => {
        handleAddFileConfirm(folderId);
      }}
      onCancel={() => {
        handleAddFileCancel();
      }}
    />
  {/if}

  <!-- í´ë” ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸ -->
  {#if showAddFolderDialog}
    <AddFolderDialog 
      isOpen={showAddFolderDialog}
      onConfirm={(folderId) => {
        handleAddFolderConfirm(folderId);
      }}
      onCancel={() => {
        handleAddFolderCancel();
      }}
    />
  {/if}

  <!-- íŒŒì¼/í´ë” ì´ë¦„ ë³€ê²½ ë‹¤ì´ì–¼ë¡œê·¸ -->
  {#if showRenameDialog}
    {@const selectedFileId = Array.from($fileManagerState.selection.selectedFiles)[0]}
    {@const selectedFolderId = Array.from($fileManagerState.selection.selectedFolders)[0]}
    {@const selectedFile = selectedFileId ? $fileManagerState.files.find(f => f.id === selectedFileId) : null}
    {@const selectedFolder = selectedFolderId ? $fileManagerState.folders.find(f => f.id === selectedFolderId) : null}
    <RenameDialog
      bind:isOpen={showRenameDialog}
      file={selectedFile}
      folder={selectedFolder}
      on:close={handleRenameCancel}
      on:renamed={handleRenameComplete}
    />
  {/if}
</div>

<style>
  /* íŒŒì¼ ë§¤ë‹ˆì € ì „ìš© ìŠ¤íƒ€ì¼ */
  .file-manager {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .folder-tree-panel {
    min-width: 200px;
    max-width: 400px;
    resize: horizontal;
    overflow: auto;
  }

  .file-list-panel {
    min-width: 0; /* flexbox ì˜¤ë²„í”Œë¡œìš° ë°©ì§€ */
  }

  .path-bar {
    user-select: text; /* ê²½ë¡œ í…ìŠ¤íŠ¸ ì„ íƒ ê°€ëŠ¥ */
  }

  .error-banner {
    animation: slideDown 0.3s ease-out;
  }

  @keyframes slideDown {
    from {
      transform: translateY(-100%);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  /* ë“œë˜ê·¸ ì•¤ ë“œë¡­ ìŠ¤íƒ€ì¼ */
  .drag-over {
    background-color: rgba(59, 130, 246, 0.1) !important;
    border: 2px dashed #3b82f6 !important;
    position: relative;
  }

  .drag-over::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(59, 130, 246, 0.05);
    z-index: 1;
    pointer-events: none;
  }

  .drag-over::after {
    content: 'íŒŒì¼ì„ ì—¬ê¸°ì— ë“œë¡­í•˜ì„¸ìš”';
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(59, 130, 246, 0.9);
    color: white;
    padding: 1rem 2rem;
    border-radius: 0.5rem;
    font-size: 1.25rem;
    font-weight: 600;
    z-index: 1000;
    pointer-events: none;
  }

  /* ì—…ë¡œë“œ ì§„í–‰ë¥  ìŠ¤íƒ€ì¼ */
  .upload-progress {
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
    padding: 1rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    min-width: 300px;
  }

  .progress-item {
    margin-bottom: 0.5rem;
  }

  .progress-bar {
    width: 100%;
    height: 0.5rem;
    background-color: #e5e7eb;
    border-radius: 0.25rem;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background-color: #3b82f6;
    transition: width 0.3s ease;
  }

  /* ë°˜ì‘í˜• ë””ìì¸ */
  @media (max-width: 768px) {
    .folder-tree-panel {
      min-width: 150px;
      max-width: 250px;
    }
    
    .upload-progress {
      bottom: 0.5rem;
      right: 0.5rem;
      left: 0.5rem;
      min-width: auto;
    }
  }

  /* ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜¤ë²„ë ˆì´ ìŠ¤íƒ€ì¼ */
  .drag-overlay {
    animation: dragPulse 1.5s ease-in-out infinite;
    backdrop-filter: blur(2px);
  }

  @keyframes dragPulse {
    0%, 100% {
      opacity: 0.8;
    }
    50% {
      opacity: 0.9;
    }
  }

  /* ë“œë˜ê·¸ ì˜¤ë²„ ìƒíƒœì—ì„œ íŒŒì¼ ë§¤ë‹ˆì € ìŠ¤íƒ€ì¼ ë³€ê²½ */
  .file-manager.drag-over {
    background-color: #eff6ff;
    border: 2px dashed #3b82f6;
  }

  /* í•œêµ­ì–´ í…ìŠ¤íŠ¸ ìµœì í™” */
  .text-korean {
    word-break: keep-all;
    line-height: 1.5;
  }

  /* ì—…ë¡œë“œ ì§„í–‰ë¥  í‘œì‹œ ìŠ¤íƒ€ì¼ */
  .upload-progress-overlay {
    animation: slideInRight 0.3s ease-out;
    max-width: 400px;
  }

  @keyframes slideInRight {
    from {
      opacity: 0;
      transform: translateX(20px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  .upload-item {
    transition: all 0.2s ease;
  }

  .upload-item:hover {
    background-color: #f8fafc;
    border-radius: 4px;
    padding: 2px;
  }

  /* ì§„í–‰ë¥  ë°” ì• ë‹ˆë©”ì´ì…˜ */
  .upload-progress-overlay .bg-blue-600,
  .upload-progress-overlay .bg-green-600 {
    transition: width 0.3s ease-out, background-color 0.3s ease;
  }

  /* ìŠ¤í¬ë¡¤ë°” ìŠ¤íƒ€ì¼ë§ */
  .folder-tree-panel::-webkit-scrollbar,
  .file-list-panel::-webkit-scrollbar {
    width: 6px;
  }

  .folder-tree-panel::-webkit-scrollbar-track,
  .file-list-panel::-webkit-scrollbar-track {
    background: #f1f5f9;
  }

  .folder-tree-panel::-webkit-scrollbar-thumb,
  .file-list-panel::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 3px;
  }

  .folder-tree-panel::-webkit-scrollbar-thumb:hover,
  .file-list-panel::-webkit-scrollbar-thumb:hover {
    background: #94a3b8;
  }

  /* ë°˜ì‘í˜• ë””ìì¸ */
  @media (max-width: 768px) {
    .folder-tree-panel {
      width: 200px;
    }
  }

  @media (max-width: 640px) {
    .folder-tree-panel {
      position: absolute;
      left: -100%;
      z-index: 10;
      height: 100%;
      transition: left 0.3s ease;
    }

    .folder-tree-panel.mobile-open {
      left: 0;
    }
  }
</style>